================================================================================
BATCH 2 — DATA MODEL & FIREBASE SCHEMA
Wall Street Fantasy League MVP — Query Examples
================================================================================

1. MATCH LOBBY QUERIES
----------------------

Q1.1: Get Open Public Matches (sorted by start date)
-----------------------------------------------------
Purpose: Display match lobby with upcoming public matches
Collection: matches
Filter: status == "OPEN" AND type == "PUBLIC"
Order: startDate ASC
Limit: 20
Index Required: I2 (status, type, startDate)

Query Pattern:
  db.collection("matches")
    .where("status", "==", "OPEN")
    .where("type", "==", "PUBLIC")
    .orderBy("startDate", "asc")
    .limit(20)

Expected Reads: 20 documents
Expected Latency: < 100ms

Sample Result:
  [
    { matchId: "m1", name: "Daily Dash", startDate: "2024-06-21", playerCount: 8 },
    { matchId: "m2", name: "Tech Weekly", startDate: "2024-06-24", playerCount: 15 },
    ...
  ]

Q1.2: Get Match Details by ID
-----------------------------
Purpose: Display full match information
Collection: matches
Filter: Document ID
Index Required: None (document lookup)

Query Pattern:
  db.collection("matches").doc(matchId).get()

Expected Reads: 1 document
Expected Latency: < 50ms

Q1.3: Join Private Match by Code
--------------------------------
Purpose: Find private match by join code
Collection: matches
Filter: matchCode == {code} AND status == "OPEN"
Index Required: Auto single-field on matchCode

Query Pattern:
  db.collection("matches")
    .where("matchCode", "==", code)
    .where("status", "==", "OPEN")
    .limit(1)

Expected Reads: 1 document
Expected Latency: < 50ms

2. USER MATCH QUERIES
---------------------

Q2.1: Get User's Active Matches
-------------------------------
Purpose: Show matches user is currently participating in
Collection: matchParticipants
Filter: userId == {uid}
Order: joinedAt DESC
Limit: 10
Index Required: I11 (userId, joinedAt DESC)

Query Pattern:
  db.collection("matchParticipants")
    .where("userId", "==", uid)
    .orderBy("joinedAt", "desc")
    .limit(10)

Expected Reads: 10 documents + 10 match lookups
Expected Latency: < 150ms (with denormalized match data)

Q2.2: Get User's Created Matches
--------------------------------
Purpose: Show matches user has created
Collection: matches
Filter: creatorId == {uid}
Order: createdAt DESC
Limit: 10
Index Required: I3 (creatorId, createdAt DESC)

Query Pattern:
  db.collection("matches")
    .where("creatorId", "==", uid)
    .orderBy("createdAt", "desc")
    .limit(10)

Expected Reads: 10 documents
Expected Latency: < 100ms

Q2.3: Get User's Match History (Results)
----------------------------------------
Purpose: Show user's completed match results
Collection: results
Filter: userId == {uid}
Order: calculatedAt DESC
Limit: 20
Index Required: I7 (userId, calculatedAt DESC)

Query Pattern:
  db.collection("results")
    .where("userId", "==", uid)
    .orderBy("calculatedAt", "desc")
    .limit(20)

Expected Reads: 20 documents
Expected Latency: < 100ms

3. LEADERBOARD QUERIES
----------------------

Q3.1: Get Match Leaderboard (Top 20)
------------------------------------
Purpose: Display match leaderboard
Collection: leaderboard
Filter: matchId == {id}
Order: rank ASC
Limit: 20
Index Required: I9 (matchId, rank ASC)

Query Pattern:
  db.collection("leaderboard")
    .where("matchId", "==", matchId)
    .orderBy("rank", "asc")
    .limit(20)

Expected Reads: 20 documents
Expected Latency: < 100ms

Q3.2: Get Match Leaderboard (Paginated)
---------------------------------------
Purpose: Load more leaderboard entries
Collection: leaderboard
Filter: matchId == {id}
Order: rank ASC
Start After: last document from previous page
Limit: 20
Index Required: I9 (matchId, rank ASC)

Query Pattern:
  db.collection("leaderboard")
    .where("matchId", "==", matchId)
    .orderBy("rank", "asc")
    .startAfter(lastDoc)
    .limit(20)

Expected Reads: 20 documents
Expected Latency: < 100ms

Q3.3: Get User's Rank in Match
------------------------------
Purpose: Find specific user's position
Collection: results
Filter: matchId == {id} AND userId == {uid}
Index Required: None (compound key lookup)

Query Pattern:
  db.collection("results")
    .doc(`${matchId}_${userId}`)
    .get()

Expected Reads: 1 document
Expected Latency: < 50ms

4. PORTFOLIO QUERIES
--------------------

Q4.1: Get User's Portfolio for Match
------------------------------------
Purpose: Display user's portfolio in a match
Collection: portfolios
Filter: matchId == {id} AND userId == {uid}
Index Required: I4 partial match

Query Pattern:
  db.collection("portfolios")
    .where("matchId", "==", matchId)
    .where("userId", "==", uid)
    .limit(1)

Expected Reads: 1 document
Expected Latency: < 50ms

Q4.2: Get All Portfolios in Match
---------------------------------
Purpose: Backend settlement processing
Collection: portfolios
Filter: matchId == {id}
Order: submittedAt ASC
Index Required: I4 (matchId, submittedAt ASC)

Query Pattern:
  db.collection("portfolios")
    .where("matchId", "==", matchId)
    .orderBy("submittedAt", "asc")

Expected Reads: Up to 100 documents (max players)
Expected Latency: < 200ms

5. PRICE DATA QUERIES
---------------------

Q5.1: Get Price Snapshot for Symbol and Date
--------------------------------------------
Purpose: Lookup specific price for settlement
Collection: priceSnapshots
Filter: Document ID = {date}_{symbol}_{exchange}
Index Required: None (document lookup)

Query Pattern:
  db.collection("priceSnapshots")
    .doc(`${date}_${symbol}_${exchange}`)
    .get()

Expected Reads: 1 document
Expected Latency: < 50ms

Q5.2: Get All Prices for Date
-----------------------------
Purpose: Batch price fetch for multiple symbols
Collection: priceSnapshots
Filter: date == {date}
Index Required: I13 (date, fetchedAt DESC)

Query Pattern:
  db.collection("priceSnapshots")
    .where("date", "==", date)
    .orderBy("fetchedAt", "desc")

Expected Reads: Up to 50 documents per match
Expected Latency: < 150ms

Q5.3: Get Price History for Symbol
----------------------------------
Purpose: Display price chart (future feature)
Collection: priceSnapshots
Filter: symbol == {symbol}
Order: date DESC
Limit: 30
Index Required: I12 (symbol, date ASC)

Query Pattern:
  db.collection("priceSnapshots")
    .where("symbol", "==", symbol)
    .orderBy("date", "desc")
    .limit(30)

Expected Reads: 30 documents
Expected Latency: < 100ms

6. SYMBOL SEARCH QUERIES
------------------------

Q6.1: Search Symbols by Prefix
------------------------------
Purpose: Autocomplete in portfolio builder
Collection: symbolCache
Filter: isEligible == true AND symbol >= {prefix} AND symbol < {prefix+\uffff}
Order: symbol ASC
Limit: 10
Index Required: I14 (isEligible, symbol ASC)

Query Pattern:
  db.collection("symbolCache")
    .where("isEligible", "==", true)
    .where("symbol", ">=", prefix.toUpperCase())
    .where("symbol", "<", prefix.toUpperCase() + "\uffff")
    .orderBy("symbol", "asc")
    .limit(10)

Expected Reads: 10 documents
Expected Latency: < 150ms

Q6.2: Get Symbol Details
------------------------
Purpose: Display symbol information in portfolio
Collection: symbolCache
Filter: Document ID = {symbol}_{exchange}
Index Required: None (document lookup)

Query Pattern:
  db.collection("symbolCache")
    .doc(`${symbol}_${exchange}`)
    .get()

Expected Reads: 1 document
Expected Latency: < 50ms

7. PARTICIPANT QUERIES
----------------------

Q7.1: Get Match Participants
----------------------------
Purpose: Show who joined a match
Collection: matchParticipants
Filter: matchId == {id}
Order: joinedAt ASC
Limit: 100
Index Required: I10 (matchId, joinedAt ASC)

Query Pattern:
  db.collection("matchParticipants")
    .where("matchId", "==", matchId)
    .orderBy("joinedAt", "asc")
    .limit(100)

Expected Reads: Up to 100 documents
Expected Latency: < 150ms

Q7.2: Check If User Already Joined
----------------------------------
Purpose: Prevent duplicate joins
Collection: matchParticipants
Filter: Document ID = {matchId}_{userId}
Index Required: None (document lookup)

Query Pattern:
  db.collection("matchParticipants")
    .doc(`${matchId}_${userId}`)
    .get()

Expected Reads: 1 document
Expected Latency: < 50ms

8. SETTLEMENT QUERIES (Backend)
-------------------------------

Q8.1: Get Matches Ready for Start
---------------------------------
Purpose: Cloud Scheduler finds matches to start
Collection: matches
Filter: status == "OPEN" AND startDate <= now
Index Required: I1 (status, startDate ASC)

Query Pattern:
  db.collection("matches")
    .where("status", "==", "OPEN")
    .where("startDate", "<=", now)
    .limit(50)

Expected Reads: Variable (batch size)
Expected Latency: < 200ms

Q8.2: Get Matches Ready for Settlement
--------------------------------------
Purpose: Cloud Scheduler finds matches to settle
Collection: matches
Filter: status == "LIVE" AND endDate <= now
Index Required: Similar to I1

Query Pattern:
  db.collection("matches")
    .where("status", "==", "LIVE")
    .where("endDate", "<=", now)
    .limit(50)

Expected Reads: Variable (batch size)
Expected Latency: < 200ms

================================================================================
QUERY COST SUMMARY
================================================================================

Query Type                    | Reads/Call | Calls/Day (Est.) | Daily Reads
------------------------------|------------|------------------|-------------
Match lobby                   | 20         | 10,000           | 200,000
Match details                 | 1          | 50,000           | 50,000
User's matches                | 10         | 5,000            | 50,000
Leaderboard                   | 20         | 20,000           | 400,000
Portfolio lookup              | 1          | 30,000           | 30,000
Symbol search                 | 10         | 20,000           | 200,000
Price lookups (settlement)    | 50         | 500              | 25,000
------------------------------|------------|------------------|-------------
ESTIMATED DAILY TOTAL         |            |                  | ~955,000

Firestore pricing (as of 2024):
- First 50,000 reads/day: Free
- Additional reads: $0.06 per 100,000

Estimated daily cost: ~$0.54/day at scale

================================================================================
END OF QUERY EXAMPLES
================================================================================
